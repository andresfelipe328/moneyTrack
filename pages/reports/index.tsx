import Head from 'next/head'
import {useState} from 'react'

import BasicLayout from '@/components/layouts/BasicLayout'
import BarGraph from '@/components/reports/BarGraph'
import FinanceOverview from '@/components/reports/FinanceOverview'
import PieChart from '@/components/reports/PieChart'
import SpendingOverview from '@/components/reports/SpendingOverview'

import nookies from 'nookies'
import { verifyIDToken } from '@/config/firebaseadmin'
import { GetServerSidePropsContext } from 'next'
import { doc, getDoc } from 'firebase/firestore'
import { db } from '@/config/firebase'
import { client } from '@/config/plaid'
import { Transaction } from 'plaid'
import { ChartContent } from '@/utils/data_types'
import uniqolor from 'uniqolor'
import { ThreeCircles } from 'react-loader-spinner'

type Props = {
   spending: Transaction[],
   bills: Transaction[],
   earnings: Transaction[],
   userID: string
}

export default function Reports({spending, bills, earnings, userID}: Props) {
   const todayDate = new Date()
   const [date, setDate] = useState(new Date().toISOString().slice(0,7))
   const [monthSpending, setMonthSpending] = useState<Transaction[]>(spending)
   const [monthBills, setMonthBills] = useState<Transaction[]>(bills)
   const [monthEarnings, setMonthEarnings] = useState<Transaction[]>(earnings)
   const [loading, setLoading] = useState(false)

   const fetchMonthData = async (e:any) => {
      setLoading(true)
      setDate(e.target.value)
      const dateItems = e.target.value.split('-')
      const newDate = new Date(Number(dateItems[0]), Number(dateItems[1]) - 1)
      const firstDate = new Date(newDate.getFullYear(), newDate.getMonth(), 1).toISOString().slice(0, 10)
      const lastDate = Number(dateItems[1]) - 1 === todayDate.getMonth() 
         ?
            todayDate.toISOString().slice(0, 10)
         :
            new Date(newDate.getFullYear(), newDate.getMonth() + 1, 0).toISOString().slice(0, 10)

      const response = await fetch('/api/month_report', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
         body: JSON.stringify({userID, firstDate, lastDate}),
      });
      response.json().then((data) => {
         setLoading(false)
         setMonthSpending(data.spending)
         setMonthBills(data.bills)
         setMonthEarnings(data.earnings)
      })
   }

   const createContent = () => {
      let content:ChartContent[] = []
      monthSpending.forEach(item => {
         if (!content.find((data) => data.label === item.category![0])) {
            const color = uniqolor.random()
            content.push({
               label: item.category![0],
               amount: Math.abs(item.amount),
               color: color
            })
         }
         else{
            const spendCateg = content.find((data) => data.label === item.category![0])!
            spendCateg.amount += Math.abs(item.amount)
         } 
      })
      return content
   }

   const chartContent = monthSpending && createContent()

   return (
      <>
         <Head>
         <title>Reports</title>
         <meta name="description" content="Generated by create next app" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="icon" href="/favicon.ico" />
         </Head>

         <BasicLayout>
            <div className='flex items-center gap-2'>
               <h1>Reports</h1>
               <input 
                  type="month" 
                  value={date} 
                  max={todayDate.toISOString().slice(0,7)} 
                  onChange={fetchMonthData}
               />
            </div>
            { !loading 
               ?
                  <>      
                     <div className="flex flex-col gap-2 h-max rounded-md bg-secondary-dark/[50%] shadow-md p-2">
                        <h2 className="bg-primary-dark py-2 px-4 rounded-md shadow-label w-fit text-extra-light">Finances</h2>
                        <div className='h-[12rem] w-[75%] sm-width:w-full mx-auto'>
                           <BarGraph spending={monthSpending} earnings={monthEarnings} date={date}/>
                        </div>
                        <FinanceOverview earnings={monthEarnings} spending={monthSpending} bills={monthBills} date={date}/>
                     </div>

                     <div className="flex flex-col gap-2 h-max rounded-md bg-secondary-dark/[50%] shadow-md p-2">
                        <h2 className="bg-primary-dark py-2 px-4 rounded-md shadow-label w-fit text-extra-light">Spending</h2>
                        <div className="w-full flex flex-col">
                           <PieChart spending={chartContent}/>
                           <SpendingOverview spending={chartContent}/>
                        </div>
                     </div>
                  </>
               :
                  <div className='grid place-items-center h-full '>
                     <ThreeCircles
                        height="80"
                        width="80"
                        outerCircleColor="#F5CB5C"
                        innerCircleColor="#5b827a"
                        middleCircleColor="#c25451"
                        ariaLabel="tail-spin-loading"
                     />
                  </div>
            }
         </BasicLayout>
      </>
   )
}

export const getServerSideProps = async (ctx: GetServerSidePropsContext) => {
   try {
      const cookies = nookies.get(ctx)
      const token = await verifyIDToken(cookies.token)
      const linkref = doc(db, `users/${token.uid}/linkBankAcc`, 'linkBankAccInfo')
      const linkSnap = await getDoc(linkref)
      let spending:Transaction[] = []
      let bills:Transaction[] = []
      let earnings:Transaction[] = []
 
      if (!linkSnap.exists())
         return {
            redirect: {destination: '/link-bank-account'}
         }
      else {
         const todayDate: Date = new Date()
         const access_token = linkSnap.data().accessToken

         const response = await client.accountsBalanceGet({
               access_token
            });
         const accounts = response.data.accounts;
         const omitAcc = ['credit', 'loan']
         let accountIDs:string[] = []

         accounts.forEach((acc:any) => {
         if (!omitAcc.includes(acc.type)) {
            accountIDs.push(acc.account_id)
         }
         })

         const firstMonthDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), 1).toISOString().slice(0, 10)
         const monthlyTranscations = await client.transactionsGet({
         access_token,
         start_date: firstMonthDate,
         end_date: todayDate.toISOString().slice(0,10),
         options: {
            account_ids: accountIDs
         }
         });
         let transactions = monthlyTranscations.data.transactions

         while(transactions.length < monthlyTranscations.data.total_transactions) {
         const remainingTransactions = await client.transactionsGet({
            access_token,
            start_date: firstMonthDate,
            end_date: todayDate.toISOString().slice(0,10),
            options: {
               offset: transactions.length,
            }
         });
         transactions = transactions.concat(remainingTransactions.data.transactions)
         }
         const omitCategories = ['Transfer', 'Credit Card', 'Deposit', 'Payment', 'Service']
         const billCategories = ['Service', 'Rent', 'Healthcare Services']
         transactions.reverse().forEach((transactionItem) => {
            if (!omitCategories.some((r) => transactionItem.category!.indexOf(r) >= 0) && 
                  !omitCategories.some((r) => transactionItem.name.indexOf(r) >= 0)) {
               spending.push(transactionItem)
            }
            if (billCategories.some((r) => transactionItem.category!.indexOf(r) >= 0)) {
               bills.push(transactionItem)
            }
            if (transactionItem.category!.includes('Payroll')) {
               earnings.push(transactionItem)
            }
         })
      }
      return {
         props: {
            spending,
            bills,
            earnings,
            userID: token.uid
         }
    }
 
   } catch(err) {
      return {
         redirect: {destination: '/login'}
      }
   }
}